---
layout: index
title: 数据结构 — 链表(LinkedList)
---
要看懂这个教程，你需要：
1. 一个智商基本在线的脑子。
2. 基础的JAVA知识和一个能运行java的IDE（所有数据结构都会用JAVA语言实现）。
3. 持之以恒，善始善终。

在介绍LinkedList前, 先要简要说明以下两点：

1. 什么是数据结构？为什么要学它？

2. 如何学习？

好，开始第一个问题。

现实世界中，我们常常要完成储存信息，提取信息的任务，比如，编配一本字典，将各种词语和含义存在字典内，这是信息储存；在字典的前面几页建立检索功能，这是信息提取。比如学校要储存所有学生的姓名，性别，学习成绩等，而且还要在必要的时候查询到每个人的信息等等......

数据结构是一门研究如何储存和提取数据的学科。

当信息量变得特别庞大的时候，怎么储存，怎么提取就变得特别重要，比如一座很大的图书馆，里面存了几百万本书，那么我们会看到图书馆建立了很明确的分类系统，先分几大类，比如：科学类，文学类，再在每个大类下又分出几个分支，然后每个类别都有自己的固定储存地，比如一层存科学图书，二层存文学图书等。大家想一下，如果我们不这样做，仅仅是把书毫无顺序和规则地，像堆垃圾一样堆在图书馆，那么就会面临两个问题：

1. 要找一本特定的书需要花很长时间。（Cost of Operation)。

2. 书乱堆，书之间会有很多空隙，会造成空间浪费。（Waste of Memory)。

你需要记住和理解上面的两个英语单词，今后我们会经常提到。

所以我们研究的就是：

1. 如何快速地让用户找到他/她想要的书。

2. 如何提升储存空间的利用率，避免造成浪费。

讲课的方式按照如下逻辑进行：

1. 先讲抽象数据结构，我们需要这个结构来为我们做什么，需要它实现哪些功能。

2. 解释实现它的方法。

3. 用Java将其实现。

4. 在讲解的过程中，我会讲变量比喻成图书馆的书，将内存比喻做图书馆，便于理解。

现在开始我们的“图书馆管理之旅”吧。

# 1. List：

我们现在所说的List并不是一个函数，也不是一个变量，它只是数据结构的一个概念。翻译成中文，大概就是“序列”的意思，说白了，它就是这个东西：

![Image](https://pic3.zhimg.com/80/v2-e152aa84847cc4061b5545afa19c146a_hd.jpg)

一个用来储存变量的序列，就像图书馆中的一个书架，比方说一本中等厚度的书（变量）厚度为1cm, 那么100cm长度的书架就能放100本书，道理十分简单，List就是储存多个变量的一个序列。

对于一个序列来讲，我们希望它能：

1. 储存特定类型的，特定数量的数据，比如，储存5本物理书。

2. 更改特定位置上的数据，比如，把第三本书换成语文书。

3. 能够读取特定位置上的数据，比如，把第二本书拿下来翻阅。

但人的欲望是无穷的，我们发现仅仅这样还是不太够，我们还需要：

1. 在特定位置插入一个数据，比如在第二本和第三本书间插入一本化学书。

2. 移除特定位置的数据，比如，拿掉刚才放进去的化学书。

3. 能够数出序列内的数据个数，比如，现在是五本书。



# 2. 实现思路：

我们先理解当你在编程的时候，你和计算机内存是如何交流的。

首先我们要知道，内存这个大的图书馆，虽然它很大很大，但每个位置都有一个地址，比如“二层A区xxxx”，那谁来管理图书馆空间的分配呢？它叫内存管理者（Memory Manager)，以下简称管理员，它并不是你，也就是说，你需要告诉它你的需求，比如你现在声明一个数组：

int x[3]；

那么就是告诉管理员：“喂，我需要在你这里存三个int类型的数据，你看着办吧。”

管理员会说：“好的，int类型需要四个字节的空间，三个的话需要十二个字节，嗯...让我看下哪里有空地儿...哦！就这里吧，行，X层X区XXX这个位置现在暂时是你的了，就十二个字节，你爱存什么存什么，记得用完和我说声，释放掉，别人还等着用呢。”

你说：“OK！”

这时，图书馆内某个位置就会储存上你的“x”，就像下方：
![Image](https://pic3.zhimg.com/80/v2-af5ac8d980e7ae871ec915d3e5816466_hd.jpg)

看到你的"x"了吗？看到我为什么在其他位置标上"?"了吗？

原因是：

**你并不清楚与x[3]相邻的位置是被占用还是空着。（重点）**

所以假如你现在又和管理员说：

“诶呀，需求变了，能把我的数组变成x[5]不？我现在要存五个数！”

管理员：

“你不早说？你旁边的位置刚刚被人预定了。”

也就是像这样：
![Image](https://pic3.zhimg.com/80/v2-a95e0f7cebeb3b386cf4779e821071b6_hd.jpg)

相邻的位置已经被占用了，你无法在原地把它扩充成长度为五的数组了！

那就只有两个办法：

1. 等待相邻的内存空间空出来（糟糕的方法，万一人家一直存着不放呢？）

2. 让管理员重新找一个有至少5*4 = 20个字节空间的地方，然后把原有的三个x[0-2]复制到那里，再把多出来的两个衔接上。

我们选取第二个方法，但仍然不理想，假如你现在储存一亿个数字呢？如果仅仅因为增加了一个数字就要彻底搬地方，将原有的数组复制过去，岂不是太麻烦了？

于是张三想了个办法：

“我只要在一开始就向管理员申请一个足够大的空间，这样不就不用折腾了？”

管理员听到这句话后把他拉入了黑名单，并告诉他：“图书馆空间本来就很紧张了，这种倾向于浪费储存空间来获取便利的思想一定不能有！”

是的，张三的方法降低了**Cost of Operation**，但却提高了**Waste of Memory**。

这时李四站出来了，他说只要这样做就好了：

我的所有数据没有必要相邻，只要能找到它们就好了，但是怎么能找到呢？图书馆那么大，每个数据都只储存了自己的值，也就是说，它连自己的地址都没有储存！也就是说，这个值自己是不知道自己的位置的！当你问x[0]它在哪里时，它也不知道！之所以用普通数组可以找到每个值是因为它们相邻，比如x[0]位置是201，那么x[1]位置就是202，x[8]位置就是209，只需要简单的加乘运算即可，但如果不相邻，事情就没这么简单了。

因此，对于每一个数据，不仅要储存它自己的值，还要储存下一个值的地址，这样，我才能像数组那样，只知道第一个数据的位置，就能一直顺着找下去，直到找到第n个。

这种数据结构，我们就称之为：“LinkedList", 中文好像叫链表，反正就是每个数据通过地址互相连接了起来。

如图：

![Image](https://pic2.zhimg.com/80/v2-2e80d3c5b57f55defaeaae9a42edd681_hd.jpg)

第一个元素就是head，然后最后一个元素储存的地址由于不指向任何东西，所以给它置为NULL。

那现在我要储存三个int需要几个字节的存储空间呢？

答案是3*2*4 = 24，也就是说，地址本身也占空间，所以这是它的弊端，它也一定程度增加了**Waste of Memory**，但是是可以接受的。

好，那么我们要是向B和C之间插入一个E呢？那我只需让B的地址指向E，让E的地址指向C，不就解决了吗？如果用普通的数组，那你就需要把C和D复制到下一个位置，然后在空出来的地方放上E，显然LinkedList要好很多。



# 3. JAVA实现

我们以面对对象方式去思考：

1. 我们需要一个数据类型（node), node需要能够储存一个int的"data"，和指向下一个node的“next”，于是我们有：

![Image](https://pic2.zhimg.com/80/v2-f941c7f00ce7bf26da7b70d75046114d_hd.jpg)

将next初始化为null, 但实际用的时候会让它指向具体的node。

2. 我们需要数据类型：LinkedList, 它能够储存一系列node。

首先，我们给LinkedList赋予一个add方法，它用来增加新元素。

![Image](https://pic1.zhimg.com/80/v2-85b39969e942b3b432a1b3e29421d15c_hd.jpg)

首先赋予两个变量：head和temp。head用来储存我们的表头，temp则指代temporal，是临时调用的参数，它用来传递，交换变量，相当于一个桥梁。

我们首先给first置为真，是因为如果LinkedList的元素个数为0的话，表头本身也是表尾，指向null，我们用first的真假来检验是否是第一个元素。

如果是，则直接给head赋值就好，记住这时first就是假的了，如果不是第一个元素，那么就让先让temp指向head，然后再让head变成temp，这样新元素就变成表头了，它指向原来的表头。

下一个方法：插入功能：

![Image](https://pic4.zhimg.com/80/v2-e1efaaefea26008db0a723ed5b9d6917_hd.jpg)

26行给一个For循环，循环index-1次，让temp不断地变成下一个元素，循环结束后temp是第index个元素，然后让新插入的元素的"next"指向temp的下一个元素，然后让temp指向"next",插入完成。

下一个方法：删除第一个元素：

![Image](https://pic3.zhimg.com/80/v2-e22694ce4ea1151903ce51c02d5121e6_hd.jpg)

很好理解，只需让表头变成第二个元素即可，如果删除后list为空，则让first置true。

接下来，做一个打印所有元素的方法：printAll();

![Image](https://pic1.zhimg.com/80/v2-3ecccf53332959523fa8e4a5f1857cac_hd.jpg)

好，最后做一个Runner类，装一个Main方法进去，作为我们程序的入口，检测一下程序：

![Image](https://pic3.zhimg.com/80/v2-4e58516ec9148e7ea9558366cac3f992_hd.jpg)

我们先加了9，4，7，又在最后加了4，打印出来应该是：7494，删除表头后，应该是：494。

验证：

![Image](https://pic2.zhimg.com/80/v2-a563788229f0f52895bfaec307642615_hd.jpg)

符合预期。

剩下的功能读者自行实现，关于LinkedList的内容就到这里。

[源码链接](http://link.zhihu.com/?target=https%3A//pan.baidu.com/s/1x0DCGGuQmH8zTqgxNzOoBQ)